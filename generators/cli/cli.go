package main

import (
	"fmt"
	"go/format"
	"os"
	"strings"
	"unicode"
)

func normalizeName(name string) string {
	r := []rune(name)
	r[0] = unicode.ToUpper(r[0])
	return string(r)
}

func main() {
	types := []string{
		"int",
		"int8",
		"int16",
		"int32",
		"int64",
		"uint",
		"uint8",
		"uint16",
		"uint32",
		"uint64",
	}
	var output []string
	writef := func(format string, args ...interface{}) {
		output = append(output, fmt.Sprintf(format, args...))
	}

	writef("// Code generated by generators/cli; DO NOT EDIT.\n\n")

	writef("package clip\n")

	writef("import \"fmt\"\n")

	for _, t := range types {
		writef("func (c *CLI) %s(name string) %s {\n", normalizeName(t), t)
		writef("f := c.find(name)\n")
		writef("if f == nil {\n")
		writef("	return 0\n")
		writef("}\n")
		writef("switch fv := f.value.(type) {\n")
		writef("case nil:\n")
		writef("	return 0\n")
		writef("case int:\n")
		writef("	return %s(fv)\n", t)
		writef("case int8:\n")
		writef("	return %s(fv)\n", t)
		writef("case int16:\n")
		writef("	return %s(fv)\n", t)
		writef("case int32:\n")
		writef("	return %s(fv)\n", t)
		writef("case int64:\n")
		writef("	return %s(fv)\n", t)
		writef("case uint:\n")
		writef("	return %s(fv)\n", t)
		writef("case uint8:\n")
		writef("	return %s(fv)\n", t)
		writef("case uint16:\n")
		writef("	return %s(fv)\n", t)
		writef("case uint32:\n")
		writef("	return %s(fv)\n", t)
		writef("case uint64:\n")
		writef("	return %s(fv)\n", t)
		writef("default:\n")
		writef("	panic(fmt.Sprintf(\"Cannot read %%s as %s: It's a %%T\", f.name, f.value))\n", t)
		writef("}\n")
		writef("}\n\n")

		writef("func (c *CLI) Fetch%s(name string) (%s, bool) {\n", normalizeName(t), t)
		writef("f := c.find(name)\n")
		writef("if f == nil {\n")
		writef("	return 0, false\n")
		writef("}\n")
		writef("switch fv := f.value.(type) {\n")
		writef("case nil:\n")
		writef("	return 0, false\n")
		writef("case int:\n")
		writef("	return %s(fv), true\n", t)
		writef("case int8:\n")
		writef("	return %s(fv), true\n", t)
		writef("case int16:\n")
		writef("	return %s(fv), true\n", t)
		writef("case int32:\n")
		writef("	return %s(fv), true\n", t)
		writef("case int64:\n")
		writef("	return %s(fv), true\n", t)
		writef("case uint:\n")
		writef("	return %s(fv), true\n", t)
		writef("case uint8:\n")
		writef("	return %s(fv), true\n", t)
		writef("case uint16:\n")
		writef("	return %s(fv), true\n", t)
		writef("case uint32:\n")
		writef("	return %s(fv), true\n", t)
		writef("case uint64:\n")
		writef("	return %s(fv), true\n", t)
		writef("default:\n")
		writef("	panic(fmt.Sprintf(\"Cannot read %%s as %s: It's a %%T\", f.name, f.value))\n", t)
		writef("}\n")
		writef("}\n\n")
	}

	src, err := format.Source([]byte(strings.Join(output, "")))
	if err != nil {
		panic(err)
	}
	if err = os.WriteFile("cli.generated.go", src, 0644); err != nil {
		panic(err)
	}
}
